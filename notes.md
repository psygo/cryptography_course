# Notes

- The biggest lesson in Crypto is apparently that we should absolutely not keep the algorithm secret.
    - In crypto, making the algorithm public and not being cracked is the highest badge of security there is.

## Caesar Cipher

The simplest version of the caesar cipher is through shifting the alphabet. The *key* is the amount by which you've shifted the alphabet.

If Eve knows the algorithm, she can break it:

Crypto Rule #1, **Kerckhoff's Principle**:

> Eve should not be able to break the ciphers even when she knows the cipher. (cipher = algorithm)

Even with all that, Caesar Cipher's key space is too small.

The *substitution cipher* is a predecessor of the caesar cipher, but it has a way bigger key space, since its keys are permutations of the alphabet, not only shifts, that is 26! != 26. 26! > 2^88, that is in theory more secure than 88 bits.

### Why is the Substitution Cipher not secure?

DES (56 bits), which is still being used, takes $1k to beat on 15 days.

We can use Bayes and use characteristics of the final text in order to reduce the key space drastically. Even if you encode space itself, you can still use the fact that space is more common than any letter in the alphabet.

## Randomness

Randomness is key to security. The `random` module generates pseudo-numbers, which is not very secure. Use the `secrets` module instead.

## One Time Pad

> Unbreakable Cipher... with a catch

XOR Property:

```none
message ^ random = cipher
cipher ^ random = message
```

which is actually unbreakable. Information-theoretically secure, i.e., it cannot be broken with infinite computing power.

The catch(es):

- Key stream only used once
- Key stream only known by sender and receiver
- Key stream is generated by true randomness

Given the ciphertext and XOR encryption, the text can be decrypted to *any* text in the universe. If you can decrypt it to anything, you would never be able to know if you're correct.

## Stream Cipher

The downsides of the One Time Pads:

- The key size must be of the same size as the message itself.
- Can't reuse the key stream
- Key distribution is difficult

A stream cipher is like a one time pad:

- No requirements on key stream
- Hence, not *true* randomness
- Also can reuse key stream

Examples:

- A5/1 (G2 encryption) - 52 bits (used in smartphones for a while)
- A5/2 (export version) - 17 bits
- RC4 (WEP, SSL) - 40-2048 bits

*All algorithms are kept secret*.

Challenges:

- Authenticity - MAC
    - The stream cipher is still robust even agains noisy channels. However, that might damage authenticity of the message, although you could solve that problem with a MAC, a message authentication code.
- Reuse key
    - Having the plain text and the cipher means you can use XOR to find out the key. Now, if you find out the key and it gets reused, the game is over.
- Low entropy
    - From Wikipedia: *in cryptography, entropy refers to the randomness collected by a system for use in algorithms that require random data. A lack of good entropy can leave a cryptosystem vulnerable and unable to encrypt data securely*.

With [*Linear Congruential Generator* (LCG)][lcg], you can generate random numbers inside a range and also guarantee determinism with respect to a certain seed.

[lcg]: https://en.wikipedia.org/wiki/Linear_congruential_generator

The A5/1 uses a Linear Feeback Shift Register (LFSR) to create a stream cipher.

## Block Ciphers - DES

Processing is done on blocks, instead of using a block of the size of the message.

Padding happens when the message is smaller than the size of the block.

The DES algorithm has 56 bits of security, but it could be used in a higher *mode of operation*.

The Russian counterpart to DES, GOST, features 256 bits of security. However it's considered academically broken (not in practical terms).

> Under *ECB* mode, the first 2 blocks of a message under DES will be identical.

> Double-DES can be broken by looking forwards and backwards through ciphered messages. Use triple-DES instead.

# Key Exchange

## Diffie-Hellman Key Exchange

> New directions in cryptography (1976)

Modular calculations can be used for generators:

> A generator **g** generates all the non-zero elements in the modulus.

```none
2^0 mod 5 =  1 = 1 mod 5
2^1 mod 5 =  2 = 2 mod 5
2^2 mod 5 =  4 = 4 mod 5
2^3 mod 5 =  8 = 3 mod 5
2^4 mod 5 = 16 = 1 mod 5
```

The priority of the `%` is higher than `+`, so please do use parentheses.

``
g = 3
for i in range(7):
    print(i, (g**i) % 7)
``````

The original paper was proposed with modular calculations. However, nowadays, things are done with elliptic curves.

# RSA

> Rivest-Shamir-Adleman, a public-key cryptosystem (1977).

The public key is the lock, and the private key is the lock's key. Everyone can lock the message with the lock, but only the person with the key itself can open it.

Key generation:

- `p`, `q` primes.
- `n = p * q` modulus
- `e` exponent
- `d` modular multiplicative inverse to `e`.

Public key:

- `(n, e)`
- Public encryption of message `m`.
- `c = m^e mod n`

Secret key:

- `(d)`
- Secret decryption of message `c`.
- `m = c^d mod n`

Need that

- `(m^e)^d = m^(e * d) = m^1 = m`
- Hence `e*d = 1 mod lcm(p-1, q-1)`
- Hence, if you can compute `p` and `q` from `n`, then you can break RSA.

Integer factorization has been proven to not be NP-complete, so, even if people prove it is actually a P problem, you can really say P = NP.

# Hash Functions

The hash function can take any size of input and any type of input, it doesn't have to be readable text.

Properties:

- It is a one-way deterministic function.
- The output is dependent on all input bits.
- Output is uniformly distributed.
- Impossible (difficult) to make a collision.

Use of hash functions:

- Digital signature
- Shadow files (passwords)
- HMAC (Hashed Message Authentication Code)
- Make deterministic identifiers

RSA can be used to sign messages.

## HMAC

It sounds like a digital signature, but it isn't.

1. Alice generates a key.
1. Alice pads the message with its key securely somehow
1. Hashing this padded message leads to Alice's MAC address.
1. Bob can check, through hashing the padded message, that the result is Alice's MAC address.
1. But, since he can't crack the padded message, he can't find out the key.

> Typically you use asymmetric cryptographic algorithms to exchange keys, but not to communicate, because they are too slow.

# Notes from Computerphile

Videos:

1. [One Encryption Standard to rule them all][aes]
1. [AES Explained][aes_explained]
1. [Diffie-Hellman Key Exchange][diffie_hellman]
1. [Diffie-Hellman Math][diffie_hellman_math]
1. [Feistel Cipher][feistel]


[aes]: https://youtu.be/VYech-c5Dic
[aes_explained]: https://youtu.be/O4xNJsjtN6E
[diffie_hellman]: https://youtu.be/NmM9HA2MQGI
[diffie_hellman_math]: https://youtu.be/Yjrfm_oRO0w
[feistel]: https://youtu.be/FGhj3CGxl8I


Rijndael, which is what's inside AES is everywhere, on YouTube, Bitlocker, etc.

The Feistel cipher uses XOR to encrypt and also decrypt the same thing, even in the case of one-way hash functions.
